<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>MSM/UserGuide</title>
<link rel="stylesheet" type="text/css" media="all" charset="utf-8" href="fsl/css/common.css">
<link rel="stylesheet" type="text/css" media="screen" charset="utf-8" href="fsl/css/screen.css">
<link rel="stylesheet" type="text/css" media="print" charset="utf-8" href="fsl/css/print.css">
<style type="text/css">
ul.pagetitle{
  display: inline;
  margin: 0;
  padding: 0;
  font-size: 1.5em;
}
li.pagetitle{
  display: inline;
  margin: 0;
}
td.noborder {
  border: 0;
}
</style>
</head>
<body>
<table>
<tr>
<td class="noborder">
<img src="logo.png">
</td>
<td class="noborder">
<ul class="pagetitle">
<li class="pagetitle"><a class="backlink">MSM/UserGuide</a>
</ul>
<br><br>
[<a href="FSL.html">FSL</a>]&nbsp;[<a href="TitleIndex.html">TitleIndex</a>]&nbsp;[<a href="WordIndex.html">WordIndex</a>]&nbsp;
</td>
</tr>
</table>
<hr>
<div id="page">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867"><div class="FslToolContents">
<h1>Contents</h1>
<ol><li><a href="./MSM.html">Introduction</a></li><li>User Guide<div class="contentslist"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="#Getting_started">Getting started</a><ol><li>
<a href="#MSM_Output">MSM Output</a></li></ol></li><li>
<a href="#Template_Spaces">Template Spaces</a></li><li>
<a href="#Advanced_Command_Line_Features">Advanced Command Line Features</a><ol><li>
<a href="#Combining_Warps">Combining Warps</a></li><li>
<a href="#Combining_warps_of_different_resolutions">Combining warps of different resolutions</a></li><li>
<a href="#File_Formats">File Formats</a></li><li>
<a href="#Costfunction_Weighting">Costfunction Weighting</a></li><li>
<a href="#Resolution_and_Smoothing">Resolution and Smoothing</a></li><li>
<a href="#Example">Example</a></li></ol></li><li>
<a href="#Configuration_Files">Configuration Files</a></li><li>
<a href="#Regular_Mesh_Surfaces">Regular Mesh Surfaces</a></li><li>
<a href="#Scripts">Scripts</a></li><li>
<a href="#Post_Processing">Post Processing</a><ol><li>
<a href="#Transforming_Unseen_Data">Transforming Unseen Data</a><ol><li>
<a href="#msmapplywarp:_of_spheres">msmapplywarp: of spheres</a></li><li>
<a href="#msmapplywarp:_of_anat">msmapplywarp: of anat</a></li><li>
<a href="#msmresample:">msmresample:</a><ol><li>
<a href="#Important_Options">Important Options</a></li></ol></li></ol></li><li>
<a href="#Estimating_metric_distortion">Estimating metric distortion</a></li></ol></li><li>
<a href="#References">References</a></li></ol></div></div></li></ol></div> <span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><p class="line867">
<h1 id="Getting_started">Getting started</h1>
<span class="anchor" id="line-4"></span><p class="line862">Prior to running MSM you will need to have passed your data through a surface extraction and inflation pipeline such as <a href="./FreeSurfer.html">FreeSurfer</a>, or the HCP minimal processing pipeline. This is because, if MSM is to work for your data you must have cortical surface meshes that have been mapped to the sphere. In addition, you will require a data file for each mesh, where the data may be scalar (such as sulcal depth, curvature or myelin features) or multivariate (RSNs or fMRI task maps). <span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><p class="line874">Data can be supplied as GIFTI (.func.gii or .shape.gii), ASCII (.asc) files, or as a simple text file (with '.txt' extension) provided the text file has as many columns as there are mesh vertices. Surface files may be supplied as GIFTI (surf.gii) or ASCII (.asc). In general the key files required to run MSM are the: <span class="anchor" id="line-7"></span><span class="anchor" id="line-8"></span><ul><li><p class="line891"><strong>input mesh</strong> - otherwise known as the &quot;source&quot; or &quot;moving&quot; mesh. This will be the mesh that is deformed during the registration. <span class="anchor" id="line-9"></span></li><li><p class="line891"><strong>reference mesh</strong>  - otherwise the &quot;target&quot; or &quot;fixed&quot; mesh. This represents the surface you would like the source data to be deformed to most resemble. In some cases, for example if source and target data have both been resampled onto a population average surface (such as the HCP FS_LR164k or FS_LR32k average surface) it will be sufficient to just supply an input mesh. <span class="anchor" id="line-10"></span></li><li><p class="line891"><strong>input data</strong> - the data file associated with the input mesh. This must therefore have as many data points as there are surface mesh vertices. <span class="anchor" id="line-11"></span></li><li><p class="line891"><strong>reference data</strong> - the data file associated with the referenced mesh. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span></li></ul><p class="line874">Examples of the most basic types of call to msm (using these inputs): <span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><ul><li style="list-style-type:none"><p class="line891"><strong>A.</strong>  <tt class="backtick">msm&nbsp;--inmesh=input_mesh.surf.gii&nbsp;--refmesh=ref_mesh.surf.gii&nbsp;--indata=in_data.func.gii&nbsp;--refdata=ref_data.func.gii&nbsp;-o&nbsp;~/mydirname/L.</tt> <span class="anchor" id="line-16"></span></li><li style="list-style-type:none"><p class="line891"><strong>B.</strong>  <tt class="backtick">msm&nbsp;--inmesh=average.sphere.FSLR32K.surf.gii&nbsp;--indata=in_data.func.gii&nbsp;--refdata=ref_data.func.gii&nbsp;-o&nbsp;~/mydirname/L.</tt> <span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span></li></ul><p class="line862">Where this assumes you are calling msm from the directory where the data exists. The final option (-o) is the stem of the path where you wish to output your data; we suggest ~/mydirname/L. or ~/mydirname/R. as an example of how you can input left and right hemisphere results into the same directory. Case <strong>B</strong> shows an example of how, when both datasets have been resampled to a population average surface (such as the HCP's 32k FS_LR surface), it is possible to enter just the average sphere as the input mesh. <span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span><p class="line867">
<h2 id="MSM_Output">MSM Output</h2>
<span class="anchor" id="line-21"></span><p class="line874">The most relevant outputs of MSM are: <span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><ul><li><p class="line862">~/mydirname/L<strong>.sphere.reg.surf.gii</strong> - the warped input mesh (i.e., new vertex locations - this capture the warp field, much like a *_warp.nii.gz file would for volumetric warps created by FNIRT). Note that the output name is highlighted in bold, with the example output path used as a prefix. <span class="anchor" id="line-24"></span></li><li><p class="line862">~/mydirname/L<strong>.sphere.LR.reg.surf.gii</strong> - this is a downsampled version of the above warp where the resolution of this mesh will be equivalent to the resolution of the final datamesh (see <a href="./MSM(2f)UserGuide.html#Configuration_Files">configuration files</a> ). This can be used for warping new meshes through the transformation (see <a href="./MSM(2f)UserGuide.html#Transforming_Unseen_Data">section on transformation</a>). <span class="anchor" id="line-25"></span></li><li><p class="line862">~/mydirname/L<strong>.resampledandprojected.func.gii</strong> - the input data passed through the MSM warp and projected onto the target surface (useful for vertex-wise comparison with the target). <span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span></li></ul><p class="line862">where  GIFTI outputs are used here only as examples. The program also supports output as  ASCII and VTK using the command line option <a href="./MSM(2f)UserGuide.html#Advanced_Command_Line_Features">-f</a>. <span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><p class="line867">
<h1 id="Template_Spaces">Template Spaces</h1>
<span class="anchor" id="line-30"></span><p class="line862">For cortical surface alignment it is common practice to align to a population average template space. For adults there are two prominent examples: the <a href="./FreeSurfer.html">FreeSurfer</a> fsaverage mesh and the FS_LR164k and FS_LR32k spaces for the HCP. The FS_LR164k population average space (see here for more details) is based upon fsaverage but has right and left vertex equivalence (it is symmetric). The FS_LR32k surface is a downsampled version of this for f/dMRI processing. <span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><p class="line874">An important point to note about the HCP average space is that the process used to achieve symmetry generates a mesh space rotated with respect to the fsaverage and native mesh spaces. To account for this the HCP have introduced a rotated native sphere called sphere.rot.native.surf.gii. Therefore, by example for some subject 'BOB' using HCP notation in directory /path/to/mystudy/: <span class="anchor" id="line-33"></span><span class="anchor" id="line-34"></span><ul><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/</strong> - respresents files resampled to 164k average space <span class="anchor" id="line-35"></span></li><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/fsaverage_LR32K/</strong> - represents files resampled to the 32k average space; <span class="anchor" id="line-36"></span></li><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/Native</strong>  - represents and all files relating to the subjects original 'native' mesh.  In other words the meshes directly extracted from each subjects structural image. <span class="anchor" id="line-37"></span><span class="anchor" id="line-38"></span></li></ul><p class="line874">In each subject's Native space there will be several spherical mesh representations. Using left as an example, these three meshes will be important for any further processing: <span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><ul><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.native.surf.gii</strong> - this is the mesh obtained from projecting the subject's native white matter mesh to a sphere using <a href="./FreeSurfer.html">FreeSurfer</a> <span class="anchor" id="line-41"></span></li><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.rot.native.surf.gii</strong> - this is the result of correcting for the rotation between the FS_LR and native spaces <span class="anchor" id="line-42"></span></li><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.MSMSulc.native.surf.gii</strong> - this is the result of aligning the native surface to FS_LR using HCP protocol for constrained MSM alignment of cortical folding (sulcal depth) to a group template <span class="anchor" id="line-43"></span></li><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.MSMall.native.surf.gii</strong> - this is the result of aligning the native surface to FS_LR using HCP protocol for serial alignment of folding, myelin and rfMRI to a group template <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span></li></ul><p class="line862">The important thing to take away here is that the HCP provides spheres aligned using MSM, with cortical folding as the features that drive the alignment. But, as the goal of the HCP is fMRI alignment this is highly constrained. This means the regularisation is strong (see <a href="./MSM(2f)UserGuide.html#Configuration_Files">configuration files</a> ). Therefore users may wish to define their own MSMSulc alignment. For this they must use the L.sphere.rot.native.surf.gii as the input mesh. There are also two more spheres that represent <a href="./FreeSurfer.html">FreeSurfer</a> alignment: <span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><ul><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.reg.native.surf.gii</strong> - This is the results of aligning the native sphere to fsaverage using <a href="./FreeSurfer.html">FreeSurfer</a> <span class="anchor" id="line-48"></span></li><li><p class="line891"><strong>/path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.reg.reg_LR.native.surf.gii</strong> - This is the results of transforming BOB.L.sphere.reg.native.surf.gii to the FS_LR space using CARET software <span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span></li></ul><p class="line862">These should not be required, other than for comparisons of results to <a href="./FreeSurfer.html">FreeSurfer</a>-based processing pipelines. <span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><p class="line867">
<h1 id="Advanced_Command_Line_Features">Advanced Command Line Features</h1>
<span class="anchor" id="line-53"></span><p class="line862">In addition to the required inputs to msm, there are several useful options. The most important of these is the <strong>--conf</strong> call that allows users to supply a configuration file which modifies key parameters of the registration. For optimal running of the registration a configuration file should be supplied (parameters are described in more detail <a href="./MSM(2f)UserGuide.html#Configuration_Files">below</a>). <span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><p class="line867">
<h2 id="Combining_Warps">Combining Warps</h2>
<span class="anchor" id="line-56"></span><p class="line862">Another very useful feature is the <strong>--trans</strong> option. This allows users to specify the output mesh from a previous registration stage. For example, if you wished to initialise registration of some other Native space features (such as myelin maps) by first aligning coarse folding structure using sulcal maps (as performed in our NeuroImage <a href="./MSM.html#Referencing">paper</a>), you could run registration in two stages as: <span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><ul><li style="list-style-type:none"><p class="line891"><strong>Step 1:</strong> <tt class="backtick">msm&nbsp;--inmesh=input_mesh.surf.gii&nbsp;--refmesh=ref_mesh.surf.gii&nbsp;--indata=in_SULC_data.func.gii&nbsp;--refdata=ref_SULC_data.func.gii&nbsp;--conf=myconfigSULC&nbsp;-o&nbsp;~/mySULCdirname/L.&nbsp;</tt> <br>
 <strong>Step 2:</strong> <tt class="backtick">msm&nbsp;--inmesh=input_mesh.surf.gii&nbsp;--trans=~/mySULCdirname/L.sphere.reg.surf.gii&nbsp;--refmesh=ref_mesh.surf.gii&nbsp;--indata=in_myelin_data.func.gii&nbsp;--refdata=ref_myelin_data.func.gii&nbsp;--conf=myconfmyelin&nbsp;-o&nbsp;~/myMyelindirname/L.</tt> <span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span></li></ul><p class="line874">Running registration in this way, rather than simply taking the output from the sulc registration and using it as an input mesh for the RSN registration, allows distortions for all the stages combined (e.g. sulc + myelin here) to be penalised during alignment. <span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><p class="line867">
<h2 id="Combining_warps_of_different_resolutions">Combining warps of different resolutions</h2>
<span class="anchor" id="line-63"></span><p class="line862">Sometimes the warps you wish to combine are defined on different mesh resolutions, and or the data used to drive the registration has been downsampled to a template mesh. This is common within the HCP when working with functional or diffusion data, which is aligned using MSMsulc and MSMall protocols, then resampled to the FS_LR32k mesh. In these instances it is possible to combine these warps using the <strong>--inregister</strong> option. In this instance, we can rewrite Step 2 above to include the HCP standard Sulc registration /path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.MSMSulc.native.surf.gii and we can incorporate the corresponding template mesh (/path/to/mystudy/BOB/MNINonLinear/fsaverage_LR32K/BOB.L.sphere.32k_fs_LR.surf.gii) in the following way: <span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><ul><li style="list-style-type:none"><p class="line891"><strong>Step 2:</strong> <tt class="backtick">msm&nbsp;--inmesh=input_mesh.surf.gii&nbsp;--trans=/path/to/mystudy/BOB/MNINonLinear/Native/BOB.L.sphere.MSMSulc.native.surf.gii&nbsp;--inregister=/path/to/mystudy/BOB/MNINonLinear/fsaverage_LR32K/BOB.L.sphere.32k_fs_LR.surf.gii&nbsp;--refmesh=ref_mesh.surf.gii&nbsp;--indata=in_RSN_32kdata.func.gii&nbsp;--refdata=ref_RSN_32kdata.func.gii&nbsp;--conf=myconfRSN&nbsp;-o&nbsp;~/myRSNdirname/L.</tt> <span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span></li></ul><p class="line867">
<h2 id="File_Formats">File Formats</h2>
<span class="anchor" id="line-68"></span><p class="line862">The output file format is controlled by the <strong>-f/--format</strong> option and the options are: GIFTI (surfaces are saved as .surf.gii and data as .func.gii); ASCII (surfaces are saved as .asc and data is saved as .dpv); ASCII_MAT (surfaces are saved as .asc and data is saved as a simple matrix in a textfile .txt); VTK (surfaces as .vtk and data as .txt). For more details on the .dpv format (which is <a href="./FreeSurfer.html">FreeSurfer</a> compatible, but differentiates surface from data files) please see the following blog post: <a class="http" href="http://brainder.org/2011/09/25/braindering-with-ascii-files/">http://brainder.org/2011/09/25/braindering-with-ascii-files/</a> <span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><p class="line867">
<h2 id="Costfunction_Weighting">Costfunction Weighting</h2>
<span class="anchor" id="line-71"></span><p class="line862">Costfunction weighting (CFw) can be controlled using <strong>--inweight</strong> and <strong>--refweight</strong> options. This allows you to supply a weighting mask for each of your source and reference meshes, although it is possible to run msm with only one. The CFw masks can be multivariate which allows you to vary the contribution of different features. For example in the &quot;Multimodal alignment&quot; section of our paper we use a single, multivariate CFw mask created on our template image (and therefore passed as a --refweight option) to vary the contribution of our different modalities to the registration. <span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><p class="line867">
<h2 id="Resolution_and_Smoothing">Resolution and Smoothing</h2>
<span class="anchor" id="line-74"></span><p class="line862">Two final useful parameters are <strong>--levels</strong> which allows you to control the number of resolution levels run during the course of the registration e.g. --levels=2. This supersedes the settings in the configuration file. Finally <strong>--smoothout</strong> controls the smoothing of the data after projection to the template image. By default the registration uses adaptive barycentric resampling (<a href="./MSM.html#Referencing">reference</a>). However, this option will allow the user to smooth using a gaussian kernel with an input parameter equal to the standard deviation. <span class="anchor" id="line-75"></span><span class="anchor" id="line-76"></span><p class="line867">
<h2 id="Example">Example</h2>
<span class="anchor" id="line-77"></span><p class="line874">Therefore, with all command line parameters used an msm call might look like this: <span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">msm&nbsp;--inmesh=input_mesh.surf.gii&nbsp;--trans=~/mySULCdirname/L.sphere.reg.surf.gii&nbsp;--refmesh=ref_mesh.surf.gii&nbsp;--indata=in_RSN_data.func.gii&nbsp;--refdata=ref_RSN_data.func.gii&nbsp;--inweight=in_weight_RSN.func.gii&nbsp;--refweight=ref_weight_RSN.gii&nbsp;--levels=2&nbsp;--smoothout=2&nbsp;--conf=myconfRSN&nbsp;-o&nbsp;~/myRSNdirname/L.</tt> <span class="anchor" id="line-80"></span><span class="anchor" id="line-81"></span></li></ul><p class="line874">This will repeat Step 2 above, but this time each of the meshes will have a corresponding weighting function supplied in the form of a GIFTI func.gii (but this could also be shape.gii, .asc or as matrix in a text file); the output of the registration will also be smoothed using a kernel of standard deviation 2. The registration will be stopped after two cycles or registration levels irrespective of the number of levels specified in the configuration file. <span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><p class="line867">
<h1 id="Configuration_Files">Configuration Files</h1>
<span class="anchor" id="line-84"></span><p class="line874">Configuration files modify all tunable parameters of the registration. For a full list of all registration parameters you can enter: <span class="anchor" id="line-85"></span><span class="anchor" id="line-86"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">msm&nbsp;-p</tt> <span class="anchor" id="line-87"></span><span class="anchor" id="line-88"></span></li></ul><p class="line874">Some parameters require inputs for every stage of the registration, and are input as comma separated lists e.g. --lambda=0,0.1,0.2,0.3 (for four levels). These are: <span class="anchor" id="line-89"></span><span class="anchor" id="line-90"></span><ul><li><p class="line891"><strong>--lambda</strong> weights the contribution of the regulariser relative to the similarity force.  <span class="anchor" id="line-91"></span></li><li><p class="line891"><strong>--opt</strong> selects the optimisation approach. Choice of: AFFINE or DISCRETE (default) <span class="anchor" id="line-92"></span></li><li><p class="line891"><strong>--simval</strong> selects the similarity measure for each stage of the registration. There is a choice of 1) SSD; 2) correlation (default); 3) NMI; 5) alpha entropy (only for multivariate data). SSD is enforced for affine alignment. For discrete optimisation we <em>strongly</em> recommend correlation for all datasets. The current implementations of SSD and NMI do not in general work well in the discrete case, and we do not advise using them. <span class="anchor" id="line-93"></span></li><li><p class="line891"><strong>--it</strong> controls the number of iterations at each resolution. In general affine registration will require in excess of 30 iterations. Discrete optimisation will converge after 5-10 iterations. <span class="anchor" id="line-94"></span></li><li><p class="line891"><strong>--sigma_in</strong> sets the input smoothing: this changes the smoothing kernel's standard deviation (default --sigma_in=2,2,2, but for very noisy data we suggest you smooth more) <span class="anchor" id="line-95"></span></li><li><p class="line891"><strong>--sigma_ref</strong> sets the reference smoothing: the values are equal to sigma_in by default, but you could smooth the reference less than the input if you are using an average template. <span class="anchor" id="line-96"></span></li><li><p class="line891"><strong>--datagrid</strong>  in MSM data is typically downsampled from the high resolution surfaces input_mesh and reference_mesh onto a regular (equally spaced vertex) grid. This speeds up the running of MSM without appreciably downgrading the quality of the alignment. These grids are formed from <a href="./MSM(2f)UserGuide.html#Regular_Mesh_Surfaces">subdivision of a icosahedron</a> and are coded in terms of the number of resamplings performed. For datagrids we typically we use 10K grids, which have code 5. <span class="anchor" id="line-97"></span></li><li><p class="line891"><strong>--CPgrid</strong>  the Control Point (CP) Grid is a low resolution mesh that controls the warp of the input mesh to the reference. At each iteration of the registration, the CP Grid can undergo one of a discrete set of deformations, where end points are defined by points on the sampling grid. By default the first level of the discrete optimisation is started with a 162 vertex grid (code 2) and this is increased by one for each level. <span class="anchor" id="line-98"></span></li><li><p class="line891"><strong>--SGgrid</strong>  the Sampling Grid resolution determines the maximum number of discrete deformations available to each CP and thus the maximum possible accuracy of the registration at that stage of the registration. It is set 2 levels higher than the CP resolution by default. <span class="anchor" id="line-99"></span><span class="anchor" id="line-100"></span></li></ul><p class="line867"><span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><div class="comment dashed" style="display:none"><span class="anchor" id="line-1-1"></span><p class="line862">* <strong>--aKNN</strong> sets the number of k-nearest neighbours used for estimation of similarity graph used during calculation of the alpha entropy measure (default 5). <span class="anchor" id="line-2-1"></span>* <strong>--mInt</strong>  controls the method used for interpolation of the warp from the control point grid to the input mesh, options: Thin Plate Spline (TPS) or barycentric (BARY). Although TPS was used in the paper, it has since been found that barycentric interpolation is more stable to large distortions. </div><span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><p class="line874">Other parameters need only be specified once: <span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span><ul><li><p class="line891"><strong>--excl</strong> tells MSM to ignore an 'exclusion' region; defined by thresholding (the intensity range provided by the cut threshold below)  <span class="anchor" id="line-108"></span></li><li><p class="line891"><strong>--cutthr</strong> controls the exclusion region, which is defined for all intensities between a certain intensity range. It needs two values as upper and lower thresholds for defining cut vertices. As it is usually used to mask the cut on the medial wall (which is zero valued) these values are typically --cutthr=0,0.0001 <span class="anchor" id="line-109"></span></li><li><p class="line891"><strong>--log</strong> selects the log transform to normalise the data <span class="anchor" id="line-110"></span></li><li><p class="line891"><strong>--IN</strong> used to normalize the intensity range of the target to that of the input data using histogram matching <span class="anchor" id="line-111"></span></li><li><p class="line891"><strong>--VN</strong> used to variance normalize data the input and target featuresets <span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span></li></ul><p class="line874">We supply a series of configuration files, each tuned to work with different (sulcal depth, myelin, and RSN) data. An example of the sulcal depth config file (which also forms the default parameterisation in the absence of any supplied configuration file) is: <span class="anchor" id="line-114"></span><span class="anchor" id="line-115"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">--simval=1,2,2,2</tt> <br>
 <tt class="backtick">--sigma_in=4,4,2,1</tt> <br>
 <tt class="backtick">--sigma_ref=2,2,1,1</tt><br>
 <tt class="backtick">--lambda=0,0.1,0.2,0.3</tt><br>
 <tt class="backtick">--it=50,3,3,3</tt><br>
 <tt class="backtick">--opt=AFFINE,DISCRETE,DISCRETE,DISCRETE</tt> <br>
 <tt class="backtick">--CPgrid=0,2,3,4</tt> <br>
 <tt class="backtick">--SGgrid=0,4,5,6</tt> <br>
 <tt class="backtick">--datagrid=4,4,5,6</tt> <br>
 <tt class="backtick">--IN</tt> <br>
 <span class="anchor" id="line-116"></span><span class="anchor" id="line-117"></span></li></ul><p class="line874">The comma separated lists above represent parameters per level, and the number of resolution levels run by msm can be controlled by the length of the lists specified here. Registration may also be initialised using an affine alignment step, run as an additional level at the beginning. Therefore, the above case is stating that the registration should run one affine step using: SSD as a similarity measure, 50 iterations, input mesh smoothing 4mm, reference mesh smoothing 2mm, on a data grid of resolution 2562 vertices; Following this discrete optimisation is run over 3 levels with 3 iterations at each level, using control point grid resolutions 162, 642, and 2562,  where the sampling grid resolution is 2 subdivisions above this, and the data grids have resolution: 2562, 10242 and 40962 vertices. Smoothing is applied to the source image as 4, 2, then 1mm sigma smoothing kernels, and to the reference image as 2, 1 and 1mmm smoothing. --IN indicates that the source intensity distribution is matched to the target intensity distribution, once at the beginning of the registration. <span class="anchor" id="line-118"></span><span class="anchor" id="line-119"></span><p class="line874">If you choose to edit or optimise the config files then it is important to remember that all multiresolution level parameter lists must have the same length, else the program will throw the following error: <span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><p class="line867"><tt class="backtick">MeshREG&nbsp;ERROR::&nbsp;config&nbsp;file&nbsp;parameter&nbsp;list&nbsp;lengths&nbsp;are&nbsp;inconsistent</tt> <span class="anchor" id="line-122"></span><span class="anchor" id="line-123"></span><p class="line874">In addition, as affine registration only implements the following parameters: --opt, --simval, --it, --sigma_in, --sigma_ref, --IN, --VN, --scale, --excl, for all other multi level parameters, it is necessary to supply a zero value for the AFFINE stage. <span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><p class="line867">
<h1 id="Regular_Mesh_Surfaces">Regular Mesh Surfaces</h1>
<span class="anchor" id="line-126"></span><p class="line874">The number of faces in an icosahedron is 20 and subsampling this gives rise to high resolution representations of a sphere that are used for controlling the grid spacing. Serial subsampling leads to polyhedra with the following number of faces: 42, 162, 642, 2562, 10242, 40962. These correspond to the codes: 1, 2, 3, 4, 5, 6.  Below are examples of codes 0 (icosahedron), 1 and 2 in the first row and 4 and 5 in the second row. <span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><p class="line867"><img align="middle" alt="grids.001.jpg" class="attachment" src="attachments/MSM(2f)UserGuide/grids.001.jpg" title="grids.001.jpg" width="1000" /> <span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><p class="line867">
<h1 id="Scripts">Scripts</h1>
<span class="anchor" id="line-131"></span><p class="line867">
<h1 id="Post_Processing">Post Processing</h1>
<span class="anchor" id="line-132"></span><p class="line867">
<h2 id="Transforming_Unseen_Data">Transforming Unseen Data</h2>
<span class="anchor" id="line-133"></span><p class="line862">In msm a warp or deformation field is prescribed by two meshes representing the start and end point of a transformation. For example, using the common syntax of this user guide, the warp for the left hemisphere is between the input_mesh.surf.gii and L.sphere.reg.surf.gii. These represent the same data, so have the same number of vertices and vertex numbers correspond. Therefore, the change in coordinates from the input_mesh to sphere.reg tells us where each vertex on the input_mesh has to move so as to optimise overlap of the input and reference data. Nevertheless, the warp alone is not sufficient to enable direct comparisons between the alignment of the input and reference featurespace (i.e. sulc/myelin/RSN maps) following alignment. To achieve this it is also necessary to <em>resample</em> the input features onto the reference mesh surface. This will take the features for each input mesh vertex and project them onto to the reference mesh at their <strong>new</strong> location i.e. according to L.sphere.reg.surf.gii. MSM generates the resampling of the input data automatically as L.transformed_and_reprojected.func.gii. However, if you wish to project new data through this transformation i.e. project myelin or RSN data through a sulc transformation the following functions will be necessary: <span class="anchor" id="line-134"></span><span class="anchor" id="line-135"></span><p class="line874">Two functions are supplied for the warping and resampling of unseen data: <span class="anchor" id="line-136"></span><span class="anchor" id="line-137"></span><p class="line867">
<h3 id="msmapplywarp:_of_spheres">msmapplywarp: of spheres</h3>
<span class="anchor" id="line-138"></span><ul><li style="list-style-type:none">This function allows you to pass meshes through a transformation prescribed for another surface. For example, if we passed MSM a low resolution approximation to our input_mesh (input_meshLR.surf.gii), and got a mesh input_meshLR.sphere.reg.surf.gii out of the registration, we could upsample this warp to the original mesh by applying: <span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span></li></ul><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">msmapplywarp&nbsp;input_mesh.surf.gii&nbsp;input_mesh.sphere.reg.gii&nbsp;-original&nbsp;input_meshLR.surf.gii&nbsp;-deformed&nbsp;input_meshLR.sphere.reg.surf.gii</tt> <span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span></li></ul><p class="line874">This can be useful for HCP data where fMRI data is resampled onto the low resolution 32k_FS_LR mesh, but other data lies on the high resolution 164k_FS_LR surface. It will assume that the starting point of the deformation is given by the un-deformed icosphere equivalent to input_meshLR.sphere.reg.surf.gii. However it is important to make sure with this formulation that the to-be-deformed mesh (input_mesh.surf.gii here) was in alignment with the input mesh used in the call to MSM that produces the warp input_meshLR.sphere.reg.surf.gii <span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line867">
<h3 id="msmapplywarp:_of_anat">msmapplywarp: of anat</h3>
<span class="anchor" id="line-145"></span><ul><li style="list-style-type:none">It is also possible to warp anatomical meshes (the white, pial, midthickness and inflated surfaces) through an MSM. This is, in effect, a resampling of the input anatomical surfaces onto the reference anatomy, using the spherical warp to determine the correspondences. We could therefore project the input white surface through the MSM warp by applying: <span class="anchor" id="line-146"></span><span class="anchor" id="line-147"></span></li></ul><p class="line862">. <tt class="backtick">msmapplywarp&nbsp;input_mesh.sphere.reg.gii&nbsp;output_deformed_white.surf.gii&nbsp;-anat&nbsp;target_sphere.surf.gii&nbsp;target_white.surf.gii</tt> <span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><p class="line874">Here the input_mesh.sphere.reg.gii is the deformed sphere output from MSM and the output_deformed_white.surf.gii will be the projection of this defomred sphere onto the target white surface <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line867">
<h3 id="msmresample:">msmresample:</h3>
<span class="anchor" id="line-152"></span><ul><li style="list-style-type:none">This is a function for resampling data following an msm warp. Generally it is best to using adaptive barycentric resolution (ref), if no smoothing is required ,or gaussian otherwise. If neither resampling option is provided nearest neighbour interpolation is used An example call: <span class="anchor" id="line-153"></span><span class="anchor" id="line-154"></span></li><li class="gap" style="list-style-type:none"><p class="line891"><tt class="backtick">msmresample&nbsp;input_mesh.sphere.reg.gii&nbsp;output_metric_basename&nbsp;-labels&nbsp;input_metric.func.gii&nbsp;-project&nbsp;target_mesh.surf,gii&nbsp;-adap_bary</tt> <span class="anchor" id="line-155"></span><span class="anchor" id="line-156"></span></li></ul><p class="line874">Where output_metric_basename refers to the desired output name without the file ending (i.e. .func.gii) <span class="anchor" id="line-157"></span><span class="anchor" id="line-158"></span><p class="line867">
<h4 id="Important_Options">Important Options</h4>
<span class="anchor" id="line-159"></span><ul><li><p class="line891"><strong>-project</strong> - target surface data will be projected onto (requires argument) <span class="anchor" id="line-160"></span></li><li><p class="line891"><strong>-labels</strong> - load data file for resampling (including .txt, .asc, .func. and .shape formats, requires argument) <span class="anchor" id="line-161"></span></li><li><p class="line891"><strong>-gaussian</strong> - gaussian interpolation kernel with std deviation X (requires argument) <span class="anchor" id="line-162"></span></li><li><p class="line891"><strong>-adap_bary</strong> - use adaptive barycentric interpolation <span class="anchor" id="line-163"></span></li><li><p class="line891"><strong>-barycentric</strong> - use adaptive barycentric interpolation <span class="anchor" id="line-164"></span></li><li><p class="line891"><strong>-excl</strong> exclude the area of the cut from contributing to the resampling <span class="anchor" id="line-165"></span></li><li><p class="line891"><strong>-normalize</strong> normalize intensity range to target (requires argument) <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span></li></ul><p class="line867">
<h2 id="Estimating_metric_distortion">Estimating metric distortion</h2>
<span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><p class="line874">It is also possible to estimate the strength of the deformation in terms of how it distorts the input mesh. This can be estimated in terms of the areal distortion, or log2(A2/A1) where A1 and A2 represent mesh face areas before and after projection, respectively. Per Vertex values are taken by weighted averaging of the distortions for every mesh face connected to each vertex. Areal distortions can be estimated as: <span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><p class="line862">. <tt class="backtick">estimate_metric_distortion&nbsp;&nbsp;input_mesh.surf.gii&nbsp;input_mesh.sphere.reg.gii&nbsp;distortion_basename&nbsp;</tt> <span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><p class="line874">In general it is undesirable for areal distortions to exceed 2 or more (four fold expansion) <span class="anchor" id="line-174"></span><span class="anchor" id="line-175"></span><p class="line867">
<h1 id="References">References</h1>
<span class="anchor" id="line-176"></span><p class="line867"><span class="anchor" id="line-177"></span><span class="anchor" id="line-178"></span><div class="references"><span class="anchor" id="line-1-2"></span><p class="line862">M.F. Glasser, S.N. Sotiropoulos, J.A. Wilson, T.S. Coalson, B. Fischl, J.L. Andersson, J. Xu, S. Jbabdi, M. Webster, J. R. Polimeni, D.C. Van Essen, M. Jenkinson, The minimal preprocessing pipelines for the Human Connectome Project, <a class="nonexistent" href="./NeuroImage.html">NeuroImage</a>, Volume 80, 15 October 2013, Pages 105-124, ISSN 1053-8119, <a class="http" href="http://dx.doi.org/10.1016/j.neuroimage.2013.04.127">http://dx.doi.org/10.1016/j.neuroimage.2013.04.127</a>. </div><span class="anchor" id="line-179"></span><span class="anchor" id="bottom"></span></div>
</div>
<hr>
2017-04-20 13:28
</body>
</html>
