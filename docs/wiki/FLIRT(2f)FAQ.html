<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>FLIRT/FAQ</title>
<link rel="stylesheet" type="text/css" media="all" charset="utf-8" href="fsl/css/common.css">
<link rel="stylesheet" type="text/css" media="screen" charset="utf-8" href="fsl/css/screen.css">
<link rel="stylesheet" type="text/css" media="print" charset="utf-8" href="fsl/css/print.css">
<style type="text/css">
ul.pagetitle{
  display: inline;
  margin: 0;
  padding: 0;
  font-size: 1.5em;
}
li.pagetitle{
  display: inline;
  margin: 0;
}
td.noborder {
  border: 0;
}
</style>
</head>
<body>
<table>
<tr>
<td class="noborder">
<img src="logo.png">
</td>
<td class="noborder">
<ul class="pagetitle">
<li class="pagetitle"><a class="backlink">FLIRT/FAQ</a>
</ul>
<br><br>
[<a href="FSL.html">FSL</a>]&nbsp;[<a href="TitleIndex.html">TitleIndex</a>]&nbsp;[<a href="WordIndex.html">WordIndex</a>]&nbsp;
</td>
</tr>
</table>
<hr>
<div id="page">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867"><div class="FslToolContents">
<h1>Contents</h1>
<ol><li><a href="./FLIRT.html">Introduction</a></li><li><a href="./FLIRT(2f)UserGuide.html">User Guide</a></li><li>FAQ<div class="contentslist"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="#My_FLIRT_registration_doesn.27t_work_well_-_what_can_I_do.3F">My FLIRT registration doesn't work well - what can I do?</a></li><li>
<a href="#What_determines_the_FOV_and_voxel_size_in_FLIRT.3F">What determines the FOV and voxel size in FLIRT?</a></li><li>
<a href="#What_cost_function_and.2For_degrees_of_freedom_.28DOF.29_should_I_use_in_FLIRT.3F">What cost function and/or degrees of freedom (DOF) should I use in FLIRT?</a></li><li>
<a href="#How_do_I_transform_a_mask_with_FLIRT_from_one_space_to_another.3F">How do I transform a mask with FLIRT from one space to another?</a></li><li>
<a href="#How_do_I_do_2D_.28or_limited_DOF.29_registration_with_FLIRT.3F">How do I do 2D (or limited DOF) registration with FLIRT?</a></li><li>
<a href="#Can_I_register_to_an_image_but_use_higher.2Flower_resolution_.28voxel_size.29.3F">Can I register to an image but use higher/lower resolution (voxel size)?</a></li><li>
<a href="#How_do_I_do_a_two-stage_registration_using_the_command_line.3F">How do I do a two-stage registration using the command line?</a></li><li>
<a href="#What_are_FLIRT_schedule_files.3F">What are FLIRT schedule files?</a></li><li>
<a href="#How_do_I_get_the_value_of_the_cost_function.3F">How do I get the value of the cost function?</a></li><li>
<a href="#How_do_I_make_my_own_study-specific_template_image_with_FLIRT.3F">How do I make my own study-specific template image with FLIRT?</a></li><li>
<a href="#What_is_the_format_of_the_matrix_used_by_FLIRT.2C_and_how_does_it_relate_to_the_transformation_parameters.3F">What is the format of the matrix used by FLIRT, and how does it relate to the transformation parameters?</a></li></ol></div></div></li></ol></div> <span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><p class="line867">
<h1 id="My_FLIRT_registration_doesn.27t_work_well_-_what_can_I_do.3F">My FLIRT registration doesn't work well - what can I do?</h1>
<span class="anchor" id="line-4"></span><p class="line874">There are many reasons why a registration may not work well. Here is a general checklist of things to test and try in order to improve the registration results (please do not post a query to the FSL email list about registration results until you have gone through this list): <span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><ul><li><p class="line862">Check that the input image looks fine and that the voxel size is correct by (a) looking at the images with <tt class="backtick">slices</tt> (none of the views should look squashed or stretched) and (b) checking the voxel dimensions (pixdim) with `fslhd (Note: voxel size can be fixed using fslchpixdim) <span class="anchor" id="line-7"></span></li><li>Remove non-brain structures with BET from both images (Note that small errors in the BET results will only have a very small impact on the registration quality) <span class="anchor" id="line-8"></span></li><li><p class="line862">Use the image with the best contrast and resolution as the reference image. If this gives you the registration in the opposite direction than you wanted then the result can be easily inverted using <tt class="backtick">InvertXFM</tt> or <tt class="backtick">convert_xfm</tt>. <span class="anchor" id="line-9"></span></li><li>For 2D images (single slices) you must use one of the valid 2D degrees of freedom options (or -2D and appropriate schedules from the command line - see below) <span class="anchor" id="line-10"></span></li><li><p class="line862">If there is large bias field (slow intensity variation - especially near the end slices) then try using <tt class="backtick">fast</tt> to create a restored image (one with no bias field) and then register using the restored image. <span class="anchor" id="line-11"></span></li><li>If there are relatively small errors in some crucial region of interest (e.g. ventricles) then the registration may benefit from using cost function weighting to enhance the importance of this region. To do this a weighting image must be made which has the value of 1.0 everywhere except in the region of interest where a higher weight (e.g. 10.0) should be used. Using this weighting volume in either the GUI or command line registration calls should improve the fit in this region. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span></li></ul><p class="line867">
<h1 id="What_determines_the_FOV_and_voxel_size_in_FLIRT.3F">What determines the FOV and voxel size in FLIRT?</h1>
<span class="anchor" id="line-14"></span><p class="line874">The reference image in FLIRT determines the Field of View (FOV) and voxel size of the output image. This works in either registration mode (where it is finding the transformation that aligns the input and reference images) and also in applyxfm mode (where it is applying a saved transformation to the input image). Note that only in registration mode does it use the intensity information from the reference image. To apply saved transformations, the GUI ApplyXFM can also be used which provides the option of specifying the number of voxels and voxel size directly. <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><p class="line867">
<h1 id="What_cost_function_and.2For_degrees_of_freedom_.28DOF.29_should_I_use_in_FLIRT.3F">What cost function and/or degrees of freedom (DOF) should I use in FLIRT?</h1>
<span class="anchor" id="line-17"></span><p class="line862">There are two main types of cost function: intra-modal (least squares and normalised correlation) and inter-modal (correlation ratio and mutual information-based options). If you are registering two images of different modality then you <strong>must</strong> use an inter-modal cost function, whereas for images of the same modality either can be used, although the intra-modal options may be more accurate. Within each category there is not much to choose from - it is a practical, experience-based decision. The recommended options (to try first) are: correlation ratio (which is the default) for inter-modal and normalised correlation for intra-modal. <span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><p class="line862">The choice of DOF (Degrees of Freedom) depends largely on whether the images to be registered are intra/inter-subject and small/large FOV. When the images are of the same subject then 6 DOF is appropriate for large FOV and 3 DOF is appropriate for small FOV/single slice. If the scanner voxel size may have changed (due to calibration shifts) then it is appropriate to use 7 DOF instead of 6 (or 4 instead of 3) to compensate for global scale changes. When the images are of different subjects, including registering to standard space, then 12 DOF is appropriate for large FOV, and 6 DOF (using <a href="./FLIRT(2f)FAQ.html#What_are_FLIRT_schedule_files.3F">2D schedule files</a>) for small FOV. <span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line874">Note that for difficult registrations there is a translation only schedule file which is effectively 3 DOF, but only includes x,y,z translations. This is useful for obtaining initial position estimates when matching small FOV to large FOV, and can then be further refined. <span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><p class="line867">
<h1 id="How_do_I_transform_a_mask_with_FLIRT_from_one_space_to_another.3F">How do I transform a mask with FLIRT from one space to another?</h1>
<span class="anchor" id="line-24"></span><p class="line874">Transforming masks with FSL requires a little extra care. To steps are needed: (i) transform the mask into the new space, and (ii) rethreshold the transformed image to make it into a binary mask again. <span class="anchor" id="line-25"></span><span class="anchor" id="line-26"></span><p class="line862">Masks can be transformed from one space to another by using either one of the command line tools <tt class="backtick">flirt</tt> or <tt class="backtick">applywarp</tt>, or the <tt class="backtick">ApplyXFM</tt> GUI. <span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span><p class="line862">The threshold used (with <tt class="backtick">fslmaths</tt>) should be set depending on the intended use of the output mask. These guidelines should help in determining the correct value to use: <span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span><ul><li>a threshold near 1 (say 0.9) is conservative <span class="anchor" id="line-31"></span><ul><li style="list-style-type:none">only voxels in the new space that overlap by 90% with the original mask will be included in the new binary mask <span class="anchor" id="line-32"></span></li></ul></li><li>a threshold near 0 (say 0.1) is liberal <span class="anchor" id="line-33"></span><ul><li style="list-style-type:none">any voxel in the new space that overlaps by 10% or more with the original mask will be included in the new binary mask <span class="anchor" id="line-34"></span></li></ul></li><li>a threshold of 0.5 will (approximately) preserve the size of the original mask <span class="anchor" id="line-35"></span><ul><li style="list-style-type:none">any voxel in the new space that overlaps by 50% or more with the original mask will be included in the new binary mask <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span></li></ul></li></ul><p class="line874">The best choice of threshold will depend on the application in which the mask is being used.  For example, if the mask is being used to quantify values within an ROI and it is important to not include contamination from surrounding areas, then a high threshold should be used.  Alternatively, if the mask is being used to define an exclusion ROI then it may be better to have a liberal border, which can be achieved with a low threshold. <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line874">Example 1: transforming a mask from standard space to highres space (linear registration) <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">flirt&nbsp;-in&nbsp;standard_mask&nbsp;-ref&nbsp;highres&nbsp;-applyxfm&nbsp;-init&nbsp;standard2highres.mat&nbsp;-out&nbsp;highres_mask</tt><br>
 <tt class="backtick">fslmaths&nbsp;highres_mask&nbsp;-thr&nbsp;0.9&nbsp;-bin&nbsp;highres_mask</tt> Note that in this case either <tt class="backtick">flirt</tt>, <tt class="backtick">applywarp</tt> or the <tt class="backtick">ApplyXFM</tt> GUI could have been used for the first step. <span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span></li></ul><p class="line874">Example 2: transforming a mask from standard space to highres space (nonlinear registration) <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">applywarp&nbsp;-i&nbsp;standard_mask&nbsp;-r&nbsp;highres&nbsp;-w&nbsp;standard2highres_warp&nbsp;-out&nbsp;highres_mask</tt><br>
 <tt class="backtick">fslmaths&nbsp;highres_mask&nbsp;-thr&nbsp;0.9&nbsp;-bin&nbsp;highres_mask</tt> Note that in this case the <tt class="backtick">applywarp</tt> command must be used since there is a nonlinear transformation (warp) involved. It is also necessary to have the warp in the correct direction (<tt class="backtick">standard2highres_warp</tt> and not <tt class="backtick">highres2standard_warp</tt>), but if only the opposite direction is available (e.g. <tt class="backtick">highres2standard_warp</tt>) then this can be inverted using the <tt class="backtick">invwarp</tt> command. <span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span></li></ul><p class="line874">Example 3: transforming a mask between different resolution versions of standard space (e.g. 3mm to 2mm) <span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">flirt&nbsp;-in&nbsp;mask3mm&nbsp;-ref&nbsp;$FSLDIR/data/standard/MNI152_T1_2mm&nbsp;-applyxfm&nbsp;-usesqform&nbsp;-out&nbsp;mask2mm</tt><br>
 <tt class="backtick">fslmaths&nbsp;mask2mm&nbsp;-thr&nbsp;0.5&nbsp;-bin&nbsp;highres_mask</tt> Note that in this case the <tt class="backtick">flirt</tt> command line must be used since the <tt class="backtick">-usesqform</tt> flag aligns the images based on standard space coordinates, and not using a prior transformation matrix or warp. <span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span></li></ul><p class="line862">In each case the transformation (<tt class="backtick">flirt,&nbsp;applywarp</tt> or <tt class="backtick">ApplyXFM</tt> GUI) forces the output to be floating point, even when the input is integer. Thresholding and binarising is done by <tt class="backtick">fslmaths</tt> in the second call. <span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><p class="line867">
<h1 id="How_do_I_do_2D_.28or_limited_DOF.29_registration_with_FLIRT.3F">How do I do 2D (or limited DOF) registration with FLIRT?</h1>
<span class="anchor" id="line-54"></span><p class="line862">A simple 2D registration (including translation in x and y and rotation about the z axis) can be easily acheived by selecting the 2D-2D rigid body (3 parameter model) option under model/DOF in the GUI, or by using the <tt class="backtick">-2D</tt> option on the command line (note that the dof does not need to be set in this case). <span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><p class="line862">Registrations with different numbers of DOF or different combinations of parameters can only be achieved using schedule files and the command line version of <tt class="backtick">flirt</tt>. If the input images are 2D it is still necessary to use the -2D option as well. For more details see the section on available <a href="./FLIRT(2f)FAQ.html#What_are_FLIRT_schedule_files.3F">schedule files</a>. <span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><p class="line874">Note that when the FOV is limited, but still 3D (multiple slices) then 2D or limited DOF transformations are normally required in order for the registration to be robust. In this context a limited FOV is normally around 50% brain coverage or less. <span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><p class="line867">
<h1 id="Can_I_register_to_an_image_but_use_higher.2Flower_resolution_.28voxel_size.29.3F">Can I register to an image but use higher/lower resolution (voxel size)?</h1>
<span class="anchor" id="line-61"></span><p class="line874">The registration and resampling stages in FLIRT are totally independent. In the registration stage it tries to find the transformation that best aligns the images, using a customised global optimisation technique that operates over multiple resolutions. Once the best transformation has been found the original input image is resampled, using the transformation found previously, to match the reference image. That is, the final output image will contain intensities derived from the input image but will have a Field Of View (FOV) and voxel size that matches the reference image. If a higher or lower resolution version of the final image is required it is necessary to save the transformation from the registration stage and then apply it in a separate stage where a new reference is used to specify the desired voxel size and FOV. <span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><p class="line862">In the FLIRT GUI, the transformation is automatically saved in a file with an extension of <tt class="backtick">.mat</tt> and this transformation can be applied to the input image (for resampling) with the GUI <tt class="backtick">ApplyXFM</tt> which allows the output image voxel size and FOV to be specified either directly or by using a reference image with the appropriate size. Note that if a reference image is used it does <strong>not</strong> have to be the same image as in the registration and in fact the contents of the image (the intensities) are not used at all - only the voxel size and FOV are used. <span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><p class="line862">At the command line, the transformation can be saved using the <tt class="backtick">-omat</tt> option. This file can then be used for resampling by specifying it with the <tt class="backtick">-init</tt> and <tt class="backtick">-applyxfm</tt> options. That is, the resampling is done using <tt class="backtick">flirt</tt> with the following syntax: <span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">flirt&nbsp;-in&nbsp;inimage&nbsp;-out&nbsp;outimage&nbsp;-ref&nbsp;refimage&nbsp;-applyxfm&nbsp;-init&nbsp;savedtransform.mat</tt> <span class="anchor" id="line-68"></span><span class="anchor" id="line-69"></span></li></ul><p class="line862">In this form the reference image is used to specify the voxel size and FOV only - all intensities within it are ignored. To create a reference image of the appropriate size, if none already exists, use <tt class="backtick">fslcreatehd</tt> to make a blank image (one filled with zeros) of appropriate dimensions. Note that in previous versions <tt class="backtick">fslcreatehd</tt> did not create an image, only the <tt class="backtick">.hdr</tt> part of an Analyze file. <span class="anchor" id="line-70"></span><span class="anchor" id="line-71"></span><p class="line862">Note that when changing the FOV rather than the voxel size, the bottom left corner remains fixed. Hence, resampling to a smaller FOV will tend to cut-off the portions of the image with large x, y or z coordinates (near the right/top). In order to resample to a smaller FOV but keep say the Centre of Volume (COV) in the centre of both images it is necessary to add an extra translation to the transformation file. This can be done by adding the appropriate offsets (in mm) to the values in the right hand column (first row is x, second is y, third is z) of the transformation (<tt class="backtick">.mat</tt>) file - which is in plain text. The appropriate offset to keep the COV constant is half of the difference in the respective FOVs (in mm). <span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><p class="line867">
<h1 id="How_do_I_do_a_two-stage_registration_using_the_command_line.3F">How do I do a two-stage registration using the command line?</h1>
<span class="anchor" id="line-74"></span><p class="line862">The command line calls made in a two-stage registration of <em>imageA</em> to <em>imageB</em> to <em>imageC</em> are as follows: <span class="anchor" id="line-75"></span><span class="anchor" id="line-76"></span><p class="line867"><tt class="backtick">flirt&nbsp;[''desired&nbsp;options'']&nbsp;-in&nbsp;''imageA''&nbsp;-ref&nbsp;''imageB''&nbsp;-omat&nbsp;''transf_A_to_B.mat''</tt><br>
 <tt class="backtick">flirt&nbsp;[''desired&nbsp;options'']&nbsp;-in&nbsp;''imageB''-ref&nbsp;''imageC''&nbsp;-omat&nbsp;''transf_B_to_C.mat''</tt><br>
 <tt class="backtick">convert_xfm&nbsp;-omat&nbsp;''transf_A_to_C.mat''&nbsp;-concat&nbsp;''transf_B_to_C.mat''&nbsp;''transf_A_to_B.mat''</tt><br>
  <tt class="backtick">flirt&nbsp;-in&nbsp;''imageA''&nbsp;-ref&nbsp;''imageC''&nbsp;-out&nbsp;''imageoutput''&nbsp;-applyxfm&nbsp;-init&nbsp;''transf_A_to_C.mat''</tt> <span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span><p class="line862">The above steps perform two registrations (the first two steps) saving the respective transformations as <tt class="backtick">.mat</tt> files, then concatenate the transformations using <tt class="backtick">convert_xfm</tt>, then apply the concatenated transformation to resample the original image using <tt class="backtick">flirt</tt>. Note that the first two calls to <tt class="backtick">flirt</tt> would normally require the cost function or degrees of freedom (dof) to be set in the <em>desired options</em>. In the final call to flirt the option <tt class="backtick">-interp</tt> is useful for specifying the interpolation method to be used (the default is trilinear). <span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><p class="line874">Also note that the FLIRT GUI outputs the command line calls used to effect the two stage registration, and will be similar to the above, although they will include specification of many of the default settings. <span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><p class="line867">
<h1 id="What_are_FLIRT_schedule_files.3F">What are FLIRT schedule files?</h1>
<span class="anchor" id="line-83"></span><p class="line862">A FLIRT schedule file controls the way that the optimisation is run inside FLIRT. It consists of a list of statements in a basic scripting language that was created for FLIRT. Several schedule files are contained in the directory <tt class="backtick">$FSLDIR/etc/flirtsch</tt> and provide different levels of degrees of freedom control, such as specific settings for 2D registrations. It is only possible to perform 2D registration on the command line using schedule files (via the <tt class="backtick">-schedule</tt> option). A list of currently provided schedule files is: <span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><ul><li>sch2D_3dof - standard 2D registration with 3 DOF (1 rotation + 2 translation) <span class="anchor" id="line-86"></span></li><li>sch2D_5dof - expanded 2D registration with 5 DOF (1 rotation + 2 translation + 2 scale) <span class="anchor" id="line-87"></span></li><li>sch2D_6dof - expanded 2D registration with 6 DOF (1 rotation + 2 translation + 2 scale + 1 skew) <span class="anchor" id="line-88"></span></li><li>sch3Dtrans_3dof - translation only 3D registration (x, y and z translation searched together) <span class="anchor" id="line-89"></span></li><li>xyztrans.sch - same as sch3Dtrans_3dof <span class="anchor" id="line-90"></span></li><li>ztransonly.sch - single z-axis translation registration <span class="anchor" id="line-91"></span></li><li>simple3D.sch - reduced search form of normal 3D schedule (close to local optimisation only) <span class="anchor" id="line-92"></span></li><li>pairreg*.sch - used for siena/sienax to register using the skull scaling as a constraint <span class="anchor" id="line-93"></span><span class="anchor" id="line-94"></span></li></ul><p class="line862">No support is provided for users to write their own schedule files, but some limited documentation is available in <tt class="backtick">$FSLDIR/doc/flirt/schedule.html</tt> or at <a class="http" href="http://www.fmrib.ox.ac.uk/fsl/flirt/schedule.html">http://www.fmrib.ox.ac.uk/fsl/flirt/schedule.html</a> for those who want to understand more or try their hand at writing new schedule files. <span class="anchor" id="line-95"></span><span class="anchor" id="line-96"></span><p class="line867">
<h1 id="How_do_I_get_the_value_of_the_cost_function.3F">How do I get the value of the cost function?</h1>
<span class="anchor" id="line-97"></span><p class="line874">You can measure the cost function between two images using: <span class="anchor" id="line-98"></span><span class="anchor" id="line-99"></span><ul><li style="list-style-type:none">flirt -in inpimage -ref refimage -schedule $FSLDIR/etc/flirtsch/measurecost1.sch -init inp2ref.mat <span class="anchor" id="line-100"></span><span class="anchor" id="line-101"></span></li></ul><p class="line874">You can also select any cost (similarity) metric you want by adding the -cost option. <span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><p class="line874">The cost value is the first number of the first line that is printed.  If you want to automatically select only this then you can do: <span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><ul><li style="list-style-type:none">flirt .... | head -1 | cut -f1 -d' ' <span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span></li></ul><p class="line874">with the above flirt command. <span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><p class="line867">
<h1 id="How_do_I_make_my_own_study-specific_template_image_with_FLIRT.3F">How do I make my own study-specific template image with FLIRT?</h1>
<span class="anchor" id="line-110"></span><p class="line862">A study-specific template is an average image created from a set of structural images which represent the particular study group. For the population in general the standard template image, created from 152 individuals, is supplied as <tt class="backtick">$FSLDIR/etc/standard/avg152T1</tt>. However, for many applications this image will not represent the study group very accurately, say due to differing age or disease. Therefore it is desirable in these cases to create a study-specific template image. An affine template image (as is the <tt class="backtick">avg152T1</tt>) can be created using the following steps: <span class="anchor" id="line-111"></span><span class="anchor" id="line-112"></span><ul><li>Choose a reference image from among the set <span class="anchor" id="line-113"></span></li><li>Register each image in the set to the reference image, using flirt, and saving the output images <span class="anchor" id="line-114"></span><ul><li style="list-style-type:none"><p class="line862">e.g. <tt class="backtick">flirt&nbsp;-in&nbsp;im3&nbsp;-ref&nbsp;imref&nbsp;-dof&nbsp;12&nbsp;-out&nbsp;imout3&nbsp;-omat&nbsp;im3_to_imref.mat</tt> <span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span></li></ul></li><li class="gap"><p class="line862">Average the output images together using <tt class="backtick">fslmaths</tt> <span class="anchor" id="line-117"></span><ul><li style="list-style-type:none"><p class="line862">e.g. <tt class="backtick">fslmaths&nbsp;imout1&nbsp;-add&nbsp;imout2&nbsp;-add&nbsp;imout3&nbsp;-add&nbsp;imout4&nbsp;...&nbsp;-add&nbsp;imoutN&nbsp;-div&nbsp;N&nbsp;avg_im&nbsp;-odt&nbsp;float</tt> <span class="anchor" id="line-118"></span><span class="anchor" id="line-119"></span></li></ul></li></ul><p class="line862">The final image, <tt class="backtick">avg_im</tt> is the average, or template, image. <span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><p class="line874">Note that it is advisable to check each registration manually, &quot;by eye&quot;, in order to make sure that the average template image is not corrupted with a poor registration result. <span class="anchor" id="line-122"></span><span class="anchor" id="line-123"></span><p class="line874">More sophisticated schemes for making the target image less sensitive to the choice of the reference image can also be carried out. The simplest of these is to redo the registration and averaging using the initial average image, from above, as the reference. This process can be iterated several times if desired. Another alternative is to perform all pair-wise registrations and choose the best consensus registration, possibly using convert_xfm and rmsdiff to detect and reject &quot;outlier&quot; registrations. <span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><p class="line867">
<h1 id="What_is_the_format_of_the_matrix_used_by_FLIRT.2C_and_how_does_it_relate_to_the_transformation_parameters.3F">What is the format of the matrix used by FLIRT, and how does it relate to the transformation parameters?</h1>
<span class="anchor" id="line-126"></span><p class="line874">Initially, please note that the coordinate system used internally within FSL is a scaled mm system (the voxel coordinates multiplied by the voxel dimensions) but is also of fixed handedness, which is achieved by swapping the x voxel coordinate (x goes to N-1-x) if the voxel-to-mm mapping in the qform/sform has positive determinant. <span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><p class="line874">The affine matrix used by FLIRT is constructed in the following way: <span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><ul><li style="list-style-type:none">mat = rot_mat * skew_mat * scale_mat <span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span></li></ul><p class="line874">The scale_mat has the form: <span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">sx&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0</tt> <tt class="backtick">&nbsp;</tt> <span class="anchor" id="line-135"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">&nbsp;0&nbsp;sy&nbsp;&nbsp;0&nbsp;&nbsp;0</tt> <tt class="backtick">&nbsp;</tt> <span class="anchor" id="line-136"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">&nbsp;0&nbsp;&nbsp;0&nbsp;sz&nbsp;&nbsp;0</tt> <tt class="backtick">&nbsp;</tt> <span class="anchor" id="line-137"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;1</tt> <span class="anchor" id="line-138"></span><span class="anchor" id="line-139"></span></li></ul><p class="line874">where sx, sy, sz are the three scaling parameters. <span class="anchor" id="line-140"></span><span class="anchor" id="line-141"></span><p class="line874">The skew_mat has the form: <span class="anchor" id="line-142"></span><span class="anchor" id="line-143"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;kxy&nbsp;&nbsp;kxz&nbsp;&nbsp;0</tt> <span class="anchor" id="line-144"></span><span class="anchor" id="line-145"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;kyz&nbsp;&nbsp;0</tt> <span class="anchor" id="line-146"></span><span class="anchor" id="line-147"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0</tt> <span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;1</tt> <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line874">where kxy, kxz, kyz are the three skew parameters. <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line874">The rot_mat has the form: <span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><ul><li style="list-style-type:none">rot_mat = Rx*Ry*Rz <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span></li></ul><p class="line874">where Rx has the form: <span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0</tt> <span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;c&nbsp;&nbsp;s&nbsp;&nbsp;0</tt> <span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;-s&nbsp;&nbsp;c&nbsp;&nbsp;0</tt> <span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><p class="line867"><tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;1</tt> <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line874">where c=cos(theta) and s=sin(theta)  and similarly for Ry and Rz (with appropriate axis/dimension swapping). <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><p class="line874">The FSL convention for transformation matrices uses an implicit centre of transformation - that is, a point that will be unmoved by that transformation, which is an arbitrary choice in general.  This arbitrary centre of the transformation for FSL is at the mm origin (0,0,0) which is at the centre of the corner voxel of the image. <span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><p class="line874">When using the transformation parameters from FLIRT, there is an additional complication in that the parameters are calculated in a way that uses a different centre convention: the centre of mass of the volume. The effect of this is that each of the three matrices above end up with an adjustment in the fourth column (top three elements only) that represents a shift between the corner origin and the centre of mass, while the rest of the matrix (first three columns) is unaffected.  Once that is done the matrices are multiplied together, as indicated above, and you get your final matrix. <span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><p class="line874">The full 12 parameters are often listed by FLIRT in the following order: <span class="anchor" id="line-174"></span><span class="anchor" id="line-175"></span><ul><li style="list-style-type:none">rx ry rz tx ty tz sx sy sz kxy kxz kyz <span class="anchor" id="line-176"></span><span class="anchor" id="line-177"></span></li></ul><p class="line874">where rx, ry, rz are the rotation angles in radians (for the matrices Rx, Ry and Rz respectively) and tx, ty, tz are the translations in mm. <span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-180"></span>CategoryFAQ <a href="./CategoryFLIRT.html">CategoryFLIRT</a> <span class="anchor" id="line-181"></span><span class="anchor" id="bottom"></span></div>
</div>
<hr>
2017-04-20 13:28
</body>
</html>
