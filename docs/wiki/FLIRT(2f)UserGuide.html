<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>FLIRT/UserGuide</title>
<link rel="stylesheet" type="text/css" media="all" charset="utf-8" href="fsl/css/common.css">
<link rel="stylesheet" type="text/css" media="screen" charset="utf-8" href="fsl/css/screen.css">
<link rel="stylesheet" type="text/css" media="print" charset="utf-8" href="fsl/css/print.css">
<style type="text/css">
ul.pagetitle{
  display: inline;
  margin: 0;
  padding: 0;
  font-size: 1.5em;
}
li.pagetitle{
  display: inline;
  margin: 0;
}
td.noborder {
  border: 0;
}
</style>
</head>
<body>
<table>
<tr>
<td class="noborder">
<img src="logo.png">
</td>
<td class="noborder">
<ul class="pagetitle">
<li class="pagetitle"><a class="backlink">FLIRT/UserGuide</a>
</ul>
<br><br>
[<a href="FSL.html">FSL</a>]&nbsp;[<a href="TitleIndex.html">TitleIndex</a>]&nbsp;[<a href="WordIndex.html">WordIndex</a>]&nbsp;
</td>
</tr>
</table>
<hr>
<div id="page">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><span class="anchor" id="line-2"></span><p class="line867"><div class="FslToolContents">
<h1>Contents</h1>
<ol><li><a href="./FLIRT.html">Introduction</a></li><li>User Guide<div class="contentslist"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="#Available_GUIs">Available GUIs</a></li><li>
<a href="#Main_FLIRT_GUI">Main FLIRT GUI</a><ol><li>
<a href="#Main_Options">Main Options</a></li><li>
<a href="#Secondary_Images">Secondary Images</a></li><li>
<a href="#Model.2FDOF">Model/DOF</a></li></ol></li><li>
<a href="#Advanced_Options">Advanced Options</a></li><li>
<a href="#flirt_Command-line_Program_and_Utilities">flirt Command-line Program and Utilities</a><ol><li>
<a href="#flirt">flirt</a></li><li>
<a href="#epi_reg">epi_reg</a></li><li>
<a href="#convert_xfm">convert_xfm</a></li><li>
<a href="#img2imgcoord">img2imgcoord</a></li><li>
<a href="#img2stdcoord">img2stdcoord</a></li><li>
<a href="#std2imgcoord">std2imgcoord</a></li><li>
<a href="#applyxfm4d">applyxfm4d</a></li><li>
<a href="#rmsdiff">rmsdiff</a></li><li>
<a href="#avscale">avscale</a></li></ol></li><li>
<a href="#FLIRT_Examples">FLIRT Examples</a></li><li>
<a href="#CONVERT_XFM_Examples">CONVERT_XFM Examples</a></li><li>
<a href="#Using_FLIRT_to_Register_a_Few_FMRI_Slices">Using FLIRT to Register a Few FMRI Slices</a><ol><li>
<a href="#Introduction">Introduction</a></li><li>
<a href="#Registration">Registration</a></li><li>
<a href="#Using_with_FEAT">Using with FEAT</a></li></ol></li></ol></div></div></li><li><a href="./FLIRT(2f)FAQ.html">FAQ</a></li></ol></div> <span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><p class="line867">
<h1 id="Available_GUIs">Available GUIs</h1>
<span class="anchor" id="line-5"></span><p class="line874">FLIRT comes with a main GUI as well as three supporting guis: <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><ul><li>ApplyXFM - for applying saved transformations and changing FOVs <span class="anchor" id="line-8"></span></li><li>InvertXFM - for inverting saved transformations <span class="anchor" id="line-9"></span></li><li>ConcatXFM - for concatenating saved transformations <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span></li></ul><p class="line874">These support GUIs are self-explanatory and perform functions that are detailed in the command line versions. Only the main FLIRT GUI is described in the rest of this page. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line867">
<h1 id="Main_FLIRT_GUI">Main FLIRT GUI</h1>
<span class="anchor" id="line-14"></span><p class="line867">
<h2 id="Main_Options">Main Options</h2>
<span class="anchor" id="line-15"></span><p class="line862">The simplest use of FLIRT is to register two single volumes together. This is done by choosing the <strong>Input image -&gt; Reference image</strong> mode in the top box, then filling in the <strong>Reference image</strong> and <strong>Input image</strong> boxes with the appropriate images. The result is a registered image which will be saved to the location specified in the <strong>Output image</strong> box. All other options/boxes can be left at their default values. <span class="anchor" id="line-16"></span><span class="anchor" id="line-17"></span><p class="line862">The second mode of operation is a two stage registration which takes an input <strong>Low res image</strong> and two target images. It initially registers the low res image to a <strong>High res image</strong> and then registers this high res image to the final <strong>Reference image</strong>. The two resulting transformations are concatenated and then applied to the original low res image to create an <strong>Output image</strong> that is a version of the low res image transformed (resliced) to the reference image space. <span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><p class="line867">
<h2 id="Secondary_Images">Secondary Images</h2>
<span class="anchor" id="line-20"></span><p class="line874">Apply the estimated transform to other (secondary) images, which were originally aligned with the input/low-res image, in order to align them with the reference image. <span class="anchor" id="line-21"></span><span class="anchor" id="line-22"></span><p class="line867">
<h2 id="Model.2FDOF">Model/DOF</h2>
<span class="anchor" id="line-23"></span><p class="line874">Restrict the transformation type. For 3D to 3D mode the DOF can be set to 12 (affine), 9 (traditional), 7 (global rescale) or 6 (rigid body). In 2D to 2D mode only 3 DOF (rigid body) transformations are allowed. <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line867">
<h1 id="Advanced_Options">Advanced Options</h1>
<span class="anchor" id="line-26"></span><p class="line874">The four categories of options are: <span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span><ul><li><p class="line891"><strong>Search</strong> - select the angular range over which the initial optimisation search stage is performed. <span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span></li><li class="gap"><p class="line891"><strong>Cost Functions</strong> - select the desired cost function from a range of inter- and intra-modal functions. <span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span></li><li class="gap"><p class="line891"><strong>Interpolation</strong> - select the interpolation method to be used in the final (reslice) transformation (it is not used for the estimation stage - trilinear interpolation is always used for the estimation of the transformation). The options for this final interpolation method are: Tri-Linear; Nearest Neighbour and  * Sinc. If Sinc is chosen, further window parameters (type of windowing function and window width) can also be specified. <span class="anchor" id="line-33"></span><span class="anchor" id="line-34"></span></li><li class="gap"><p class="line891"><strong>Weighting Volumes</strong> - impose voxel-wise weighting to reference and/or input images, to affects the cost function. The weighting images must be the same size as the image they are weighting (e.g. refweight and reference images) and the voxel values of the weighting image represent how much weighting that particular voxel is given in the cost function. Therefore, by setting weights to zero, some areas of the image can be effectively ignored, which is useful in masking out pathologies so that they do not affect the registration. In this way very accurate registrations can be made between pathological and &quot;normal&quot; images. This cannot be achieved by masking the images prior to registration, as that induces artificial boundaries which bias the registration. Furthermore, some areas can be given extra weighting (such as the ventricles) so that the registration is most accurate near these structures, but still uses information from the rest of the image (e.g. the cortical surface) to improve the robustness of the registration. <span class="anchor" id="line-35"></span><span class="anchor" id="line-36"></span></li></ul><p class="line867"><img align="bottom" alt="transforms" class="attachment" src="attachments/FLIRT(2f)UserGuide/xfmhelp.gif" title="transforms" /> <span class="anchor" id="line-37"></span><span class="anchor" id="line-38"></span><p class="line867">
<h1 id="flirt_Command-line_Program_and_Utilities">flirt Command-line Program and Utilities</h1>
<span class="anchor" id="line-39"></span><p class="line862">This document gives a brief description of flirt and the various command-line programs available in the FLIRT component of FSL. A description of the available <a class="nonexistent" href="./FLIRT(2f)GUI.html">GUI</a> interfaces is also available. <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line874">For each of the programs described here, a usage message which describes the full list of available options can be obtained by running the program with no options. <span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><p class="line862">See also the list of common <a class="nonexistent" href="./Flirt(2f)Examples.html">example usages</a>. <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-46"></span>
<h2 id="flirt">flirt</h2>
<span class="anchor" id="line-47"></span><p class="line867"><tt class="backtick">flirt</tt> is the main program that performs affine registration. The main options are: an input (<tt class="backtick">-in</tt>) and a reference (<tt class="backtick">-ref</tt>) volume; the calculated affine transformation that registers the input to the reference which is saved as a 4x4 affine matrix (<tt class="backtick">-omat</tt>); and output volume (<tt class="backtick">-out</tt>) where the transform is applied to the input volume to align it with the reference volume. In addition, FLIRT can also be used to apply a saved transformation to a volume (<tt class="backtick">-applyxfm,&nbsp;-init&nbsp;and&nbsp;-out</tt>) or to apply a transform that aligns the NIFTI mm coordinates (<tt class="backtick">-applyxfm</tt>, <tt class="backtick">-usesqform</tt> and <tt class="backtick">-out</tt>; but not <tt class="backtick">-init</tt>). For these usages the reference volume must still be specified as this sets the voxel and image dimensions of the resulting volume. <span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><p class="line874">Features: <span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><p class="line867"><em>Cost Function Weighting</em> <span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><p class="line874">Weighting volumes can be specified using -refweight, -inweight (or both). This allows the cost function to have a different weighting at each voxel, which is useful for excluding areas (weight=0) of no interest, or increasing the weighting around important structures such as the ventricles. Note that this is different from masking the original images, as masking introduces artificial boundaries whereas weighting does not. <span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><p class="line867"><em>Degrees of Freedom</em> <span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><p class="line862">Choose from 6,7,9 or 12 Degrees of Freedom (DOF) for full 3D registrations. Also includes a 3DOF 2D-to-2D registration mode which is selected using the -2D option. Note that it does not perform any search in 2D mode, and cannot deal with 2D to 3D registrations. More flexible DOF options are provided by the specific schedule files provided in <tt class="backtick">$FSLDIR/etc/flirtsch</tt>. <span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><p class="line867"><em>Interpolation Methods</em> <span class="anchor" id="line-60"></span><span class="anchor" id="line-61"></span><p class="line874">This includes Nearest Neighbour, a family of Sinc-based methods (three window types - rectangular, Hanning and Blackman) with configurable window width, and spline (a highly efficient method, with similar output characteristics to sinc). The interpolation is only used for the final transformation (and in applyxfm), not in the registration calculations. <span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><p class="line867"><em>Cost Functions</em> <span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><p class="line862">This includes the within-modality functions Least Squares and Normalised Correlation, as well as the between-modality functions Correlation Ratio (the default), Mutual Information and Normalised Mutual Information.  In addition, there is the <a href="./FLIRT_BBR.html">BBR</a> cost function which utilises a segmentation of the reference image to define a boundary, and it is the intensity differences in the input image, across the transformed boundary, that contribute to the cost. <span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-68"></span>
<h2 id="epi_reg">epi_reg</h2>
<span class="anchor" id="line-69"></span><p class="line874">This is a script designed to register EPI images (typically functional or diffusion) to structural (e.g. T1-weighted) images.  The pre-requisites to use this method are: (1) a structural image that can be segmented to give a good white matter boundary; and (2) an EPI that contains some intensity contrast between white matter and grey matter (though it does not have to be enough to get a segmentation). <span class="anchor" id="line-70"></span><span class="anchor" id="line-71"></span><p class="line862">This script will either use an existing white-matter segmentation of the structural image, or create one itself, to define a white-matter boundary.  To use an existing white-matter segmentation there needs to be an image with the same basename as the input <tt class="backtick">t1brain</tt> image, but ending with <tt class="backtick">_wmseg</tt>. We recommend that the structural image is bias-corrected separately beforehand if there is obvious bias field present. <span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><p class="line862">The script is also capable of using fieldmaps to perform simultaneous registration and EPI distortion-correction.  For this it requires extra images (in the format as given by <a href="./FUGUE(2f)Guide.html#Making_Fieldmap_Images_for_FEAT">fsl_prepare_fieldmap</a> ) as well as extra information about the EPI sequence (which your operator/radiographer/technician should be able to provide, but make sure you record the values).  The inputs <tt class="backtick">echospacing</tt> and <tt class="backtick">pedir</tt> both refer to the EPI image (not the fieldmap) and are the same as required for <a href="./FEAT(2f)UserGuide.html#Pre-Stats">FEAT</a>, but be careful to use the correct units. <span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><p class="line867"><span class="anchor" id="line-76"></span><span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span><span class="anchor" id="line-88"></span><span class="anchor" id="line-89"></span><span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><span class="anchor" id="line-92"></span><pre><span class="anchor" id="line-1"></span>Usage: epi_reg [options] --epi=&lt;EPI image&gt; --t1=&lt;wholehead T1 image&gt; --t1brain=&lt;brain extracted T1 image&gt; --out=&lt;output name&gt;
<span class="anchor" id="line-2"></span>
<span class="anchor" id="line-3"></span>Optional arguments
<span class="anchor" id="line-4"></span>  --fmap=&lt;image&gt;         : fieldmap image (in rad/s)
<span class="anchor" id="line-5"></span>  --fmapmag=&lt;image&gt;      : fieldmap magnitude image - wholehead extracted
<span class="anchor" id="line-6"></span>  --fmapmagbrain=&lt;image&gt; : fieldmap magnitude image - brain extracted
<span class="anchor" id="line-7"></span>  --echospacing=&lt;val&gt;    : Effective EPI echo spacing (sometimes called dwell time) - in seconds
<span class="anchor" id="line-8"></span>  --pedir=&lt;dir&gt;          : phase encoding direction, dir = x/y/z/-x/-y/-z
<span class="anchor" id="line-9"></span>  --weight=&lt;image&gt;       : weighting image (in T1 space)
<span class="anchor" id="line-10"></span>  --noclean              : do not clean up intermediate files
<span class="anchor" id="line-11"></span>  -v                     : verbose output
<span class="anchor" id="line-12"></span>  -h                     : display this help message
<span class="anchor" id="line-13"></span>
<span class="anchor" id="line-14"></span>e.g.:  epi_reg --epi=example_func --t1=struct --t1brain=struct_brain --out=epi2struct --fmap=fmap_rads --fmapmag=fmap_mag --fmapmagbrain=fmap_mag_brain --echospacing=0.0005 --pedir=-y
<span class="anchor" id="line-15"></span>
<span class="anchor" id="line-16"></span>Note that if parallel acceleration is used in the EPI acquisition then the *effective* echo spacing is the actual echo spacing between acquired lines in k-space divided by the acceleration factor.</pre><span class="anchor" id="line-93"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-94"></span>
<h2 id="convert_xfm">convert_xfm</h2>
<span class="anchor" id="line-95"></span><p class="line867"><tt class="backtick">convert_xfm</tt> is a utility that is used to convert between different transformation file formats. It can read and write ascii 4x4 matrices. In addition, it can be used to concatenate two transforms (using <tt class="backtick">-concat</tt> with the second transform) or to find the inverse transformation (using <tt class="backtick">-inverse</tt>). <span class="anchor" id="line-96"></span><span class="anchor" id="line-97"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-98"></span>
<h2 id="img2imgcoord">img2imgcoord</h2>
<span class="anchor" id="line-99"></span><p class="line867"><tt class="backtick">img2imgcoord</tt> is a utility that calculates the corresponding coordinate positions (in voxels or mm) within a destination volume given the original coordinates in the source volume and the transformation from the source to the destination volume (either linear/affine transformations or non-linear warps). This is useful for finding corresponding anatomical/functional locations. If the option <tt class="backtick">-mm</tt> is used then both input and output coordinates will be in mm coordinates, otherwise (with <tt class="backtick">-vox</tt>) both coordinates will be in voxel coordinates.  For conversion <em>between</em> voxel and mm coordinates it is necessary to use either <tt class="backtick">img2stdcoord</tt> or <tt class="backtick">std2imgcoord</tt> (see below). <span class="anchor" id="line-100"></span><span class="anchor" id="line-101"></span><p class="line874">Note that the source coordinates can either be input via a file or via a pipe (and for the latter the &quot;-&quot; symbol is used as the filename). The format in either case is three numbers per line, space separated. <span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><p class="line862">Example usage:<br>
 <tt class="backtick">&nbsp;&nbsp;&nbsp;cat&nbsp;coordfile.txt&nbsp;|&nbsp;img2imgcoord&nbsp;-src&nbsp;example_func&nbsp;-dest&nbsp;highres&nbsp;-xfm&nbsp;example_func2highres.mat&nbsp;-</tt> <span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><p class="line867"><em>Warning</em>: currently there is a buglet in the coordinate conversion tools <tt class="backtick">img2imgcoord</tt>, <tt class="backtick">img2stdcoord</tt> and <tt class="backtick">std2imgcoord</tt> such that the last coordinate is repeated if the input is a file.  To avoid this use the pipe input format or suppress the final line:<br>
<tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cat&nbsp;coordfile.txt&nbsp;|&nbsp;img2imgcoord&nbsp;-src&nbsp;example_func&nbsp;-dest&nbsp;highres&nbsp;-xfm&nbsp;example_func2highres.mat&nbsp;-</tt> <br>
<tt class="backtick">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img2imgcoord&nbsp;-src&nbsp;example_func&nbsp;-dest&nbsp;highres&nbsp;-xfm&nbsp;example_func2highres.mat&nbsp;coordfile.txt&nbsp;|&nbsp;sed&nbsp;'$d'</tt> <span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-108"></span>
<h2 id="img2stdcoord">img2stdcoord</h2>
<span class="anchor" id="line-109"></span><p class="line867"><tt class="backtick">img2stdcoord</tt> is a similar utility to <tt class="backtick">img2imgcoord</tt> except that the destination volume coordinates are treated as mm (standard space) coordinates. This uses the &quot;standard space&quot; image's coordinate mapping information (qform/sform in the NIfTI format) to convert to mm coordinates. The coordinates for the source image can be either in voxel coordinates (default, or by explicitly using <tt class="backtick">-vox</tt>) or in mm coordinates (using <tt class="backtick">-mm</tt>).  Example usage:<br>
 <tt class="backtick">&nbsp;&nbsp;&nbsp;echo&nbsp;92&nbsp;80&nbsp;59&nbsp;|&nbsp;img2stdcoord&nbsp;-img&nbsp;highres&nbsp;-std&nbsp;standard&nbsp;-warp&nbsp;highres2standard_warp&nbsp;-</tt> <span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><p class="line862">This is useful in conjunction with the tool <a href="./Atlasquery.html">Atlasquery</a> that can report atlas labels for coordinates in standard space. <span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span><p class="line862">It is no longer the case (now that FSL uses the NIfTI format) that the image specified with <tt class="backtick">-std</tt> need to be a &quot;standard space&quot; image.  Any image can be used, and the mapping to mm coordinates will be done as it is done in FSLView (using the qform/sform information or an FSL default if they are not set).  This utility, and <tt class="backtick">std2imgcoord</tt> are therefore useful for converting between voxel and mm coordinates within the same image, as well as for mapping coordinates between spaces. <span class="anchor" id="line-114"></span><span class="anchor" id="line-115"></span><p class="line862">Converting from voxel to mm coordinates within the same image can be done with the command:<br>
 <tt class="backtick">&nbsp;&nbsp;&nbsp;echo&nbsp;X&nbsp;Y&nbsp;Z&nbsp;|&nbsp;img2stdcoord&nbsp;&nbsp;-img&nbsp;IMAGENAME&nbsp;-std&nbsp;IMAGENAME&nbsp;-vox&nbsp;-</tt><br>
 where here we convert just a single coordinate (replace X, Y, Z, and IMAGENAME with appropriate numbers/filename) but multiple coordinates can also be done by replacing the <tt class="backtick">echo&nbsp;X&nbsp;Y&nbsp;Z</tt> with <tt class="backtick">cat&nbsp;COORDFILE</tt>  (again, replacing COORDFILE with the appropriate filename). <span class="anchor" id="line-116"></span><span class="anchor" id="line-117"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-118"></span>
<h2 id="std2imgcoord">std2imgcoord</h2>
<span class="anchor" id="line-119"></span><p class="line867"><tt class="backtick">std2imgcoord</tt> is the complementary utility to <tt class="backtick">img2stdcoord</tt>. It works the same way but transfers coordinates from &quot;standard space&quot; to the other image (IMG) space.  It can also convert between mm and voxel coordinates within the same image.  See the entry on <tt class="backtick">img2stdcoord</tt> above. <span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-122"></span>
<h2 id="applyxfm4d">applyxfm4d</h2>
<span class="anchor" id="line-123"></span><p class="line867"><tt class="backtick">applyxfm4D</tt> is a utility that transforms a 4D time series by applying known affine transformations to them. It can be used with a single transformation applied to all, or using a directory of transformation files in the form MAT_XXXX (where XXXX stands for the volume number, starting with 0000). Sinc interpolation is used internally. Appropriate options (<tt class="backtick">-applyxfm</tt> and <tt class="backtick">-init</tt>) to FLIRT can be used to apply transformations to single volumes with other interpolation methods. A reference volume is required in order to determine the matrix size and FOV for the final volume. If the required matrices do not start with MAT_ a different prefix can be specified with the <tt class="backtick">-userprefix</tt> option. <span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-126"></span>
<h2 id="rmsdiff">rmsdiff</h2>
<span class="anchor" id="line-127"></span><p class="line867"><tt class="backtick">rmsdiff</tt> is a utility that calculates the Root Mean Square deviation (in millimetres) between two transformations. That is, it compares two transformations (normally two possible registrations of the same volume pair) to see how much they differ. This is useful to compare alternative registrations. It calculates the average using an analytic formula applied over an 80mm sphere with the origin at the centre of gravity of the image (for which it requires the input image to be specified). <span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><p class="line874">An alternative usage is to provide a mask (as the fourth argument) which is then used to specify the ROI, rather than using the sphere. In this mode it gives two outputs: (1) the maximum movement (in mm) over all voxels in the ROI/mask; and (2) the RMS movement (in mm) over all voxels in the ROI/mask.  With this calculation it does not require an origin to be set. <span class="anchor" id="line-130"></span><span class="anchor" id="line-131"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-132"></span>
<h2 id="avscale">avscale</h2>
<span class="anchor" id="line-133"></span><p class="line867"><tt class="backtick">avscale</tt> is a utility that displays the decomposed elements of an affine matrix. It displays the rotation/translation matrix, the individual axis scalings, the individual skews, the average scaling, and the forward and backward halfway transformations. In order to set the centre of rotation it requires the input volume (also called the reslice volume). <span class="anchor" id="line-134"></span><span class="anchor" id="line-135"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-136"></span>
<h1 id="FLIRT_Examples">FLIRT Examples</h1>
<span class="anchor" id="line-137"></span><p class="line862">The simplest usage of <tt class="backtick">flirt</tt> is to register two images together as: <span class="anchor" id="line-138"></span><span class="anchor" id="line-139"></span><p class="line867"><tt class="backtick">flirt&nbsp;-in&nbsp;invol&nbsp;-ref&nbsp;refvol&nbsp;-out&nbsp;outvol&nbsp;-omat&nbsp;invol2refvol.mat&nbsp;-dof&nbsp;6</tt> <span class="anchor" id="line-140"></span><span class="anchor" id="line-141"></span><p class="line862">where <tt class="backtick">invol</tt>, <tt class="backtick">refvol</tt>, <tt class="backtick">outvol</tt> are the input, reference and output volume filenames respectively, <tt class="backtick">invol2refvol.mat</tt> is the filename for the saved ascii transformation matrix. Naturally, any filenames you wish to use can be chosen. <span class="anchor" id="line-142"></span><span class="anchor" id="line-143"></span><p class="line862">Note that <tt class="backtick">-dof</tt> was used as the default would otherwise be 12. The default cost function is Correlation Ratio, which normally works well for all images. <span class="anchor" id="line-144"></span><span class="anchor" id="line-145"></span><p class="line862">Also note that the <tt class="backtick">.mat</tt> extension is not compulsory and any filename and extension can be used. The transformation files are simply stored as ascii matrices, and so other conventions can be used (which might be better for MATLAB users to avoid confusion) although the <tt class="backtick">.mat</tt> extension is the default within FEAT. <span class="anchor" id="line-146"></span><span class="anchor" id="line-147"></span><p class="line874">To apply a saved transformation to another image use: <span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><p class="line867"><tt class="backtick">flirt&nbsp;-in&nbsp;newvol&nbsp;-ref&nbsp;refvol&nbsp;-out&nbsp;outvol&nbsp;-init&nbsp;invol2refvol.mat&nbsp;-applyxfm</tt> <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line862">Note that the previous transformation matrix is used with the <tt class="backtick">-init</tt> command and that the size of the otput volume is determined by <tt class="backtick">refvol</tt> although its contents are <strong>not</strong> used. <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line874">To perform a 3 DOF 2D (single slice) registration: <span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><p class="line867"><tt class="backtick">flirt&nbsp;-in&nbsp;inslice&nbsp;-ref&nbsp;refslice&nbsp;-out&nbsp;outslice&nbsp;-omat&nbsp;i2r.mat&nbsp;-2D</tt> <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line874">To perform a 6 DOF 2D registration: <span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><p class="line867"><tt class="backtick">flirt&nbsp;-in&nbsp;inslice&nbsp;-ref&nbsp;refslice&nbsp;-out&nbsp;outslice&nbsp;-omat&nbsp;i2r.mat&nbsp;-2D&nbsp;-schedule&nbsp;${FSLDIR}/etc/flirtsch/sch2D_6dof</tt> <span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><p class="line862">The schedule file specifies what transformations/DOF are allowed and how the optimisation is performed. Note that several other schedule files could be used - including 3D translation only schedules etc. These are all stored in <tt class="backtick">${FSLDIR}/etc/flirtsch</tt> <span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-164"></span>
<h1 id="CONVERT_XFM_Examples">CONVERT_XFM Examples</h1>
<span class="anchor" id="line-165"></span><p class="line874">To invert a saved transformation: <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line867"><tt class="backtick">convert_xfm&nbsp;-omat&nbsp;refvol2invol.mat&nbsp;-inverse&nbsp;invol2refvol.mat</tt> <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><p class="line874">To concatenate two transformations: <span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><p class="line867"><tt class="backtick">convert_xfm&nbsp;-omat&nbsp;AtoC.mat&nbsp;-concat&nbsp;BtoC.mat&nbsp;AtoB.mat</tt> <span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><p class="line874">Note that the transform after the -concat is treated as the second transformation in the concatenation. <span class="anchor" id="line-174"></span><span class="anchor" id="line-175"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-176"></span>
<h1 id="Using_FLIRT_to_Register_a_Few_FMRI_Slices">Using FLIRT to Register a Few FMRI Slices</h1>
<span class="anchor" id="line-177"></span><p class="line867">
<h2 id="Introduction">Introduction</h2>
<span class="anchor" id="line-178"></span><p class="line874">If you need to take an FMRI data set where you only have a few slices (ie the field-of-view - FOV - is small in Z) then it is very hard to get a good registration with either the subject's structural or directly to a standard space image. This page describes our recommendations in such cases. <span class="anchor" id="line-179"></span><span class="anchor" id="line-180"></span><ul><li><p class="line862">Take your FMRI data, with only a few slices. We will refer to an example volume from this time series as <strong>example_func</strong>. <span class="anchor" id="line-181"></span><span class="anchor" id="line-182"></span></li><li class="gap"><p class="line862">Take a single whole-brain &quot;functional&quot; image (let's call this <strong>whole_func</strong>). This will normally be the same kind of image as <strong>example_func</strong> (eg EPI), but will cover the whole brain. It should contain, as a subset of its slices, the same slices as in <strong>example_func</strong>. In general there should be no rotation between <strong>func</strong> and <strong>whole_func</strong>. <span class="anchor" id="line-183"></span><span class="anchor" id="line-184"></span></li><li class="gap"><p class="line862">Now (optionally) take a high-resolution structural image, e.g. T1-weighted (let's call this <strong>highres</strong>). <span class="anchor" id="line-185"></span><span class="anchor" id="line-186"></span></li><li class="gap"><p class="line862">Finally, identify your standard space image (let's call this <strong>standard</strong>). <span class="anchor" id="line-187"></span><span class="anchor" id="line-188"></span></li></ul><p class="line874">Now you are ready to register these all together. <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-191"></span>
<h2 id="Registration">Registration</h2>
<span class="anchor" id="line-192"></span><ul><li><p class="line862">First, register <strong>example_func</strong> to <strong>whole_func</strong>: <span class="anchor" id="line-193"></span><span class="anchor" id="line-194"></span></li></ul><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;whole_func&nbsp;-in&nbsp;example_func&nbsp;-schedule&nbsp;${FSLDIR}/etc/flirtsch/ztransonly.sch&nbsp;-out&nbsp;example_func2whole_func&nbsp;-omat&nbsp;example_func2whole_func.mat</tt> <span class="anchor" id="line-195"></span><span class="anchor" id="line-196"></span><p class="line862">The custom FLIRT schedule file <tt class="backtick">ztransonly.sch</tt> allows only translations in Z (in order for the registration to be robust), so there must be no rotation or within-slice translation between these images. <span class="anchor" id="line-197"></span><span class="anchor" id="line-198"></span><ul><li>Now register whole_func to highres: <span class="anchor" id="line-199"></span><span class="anchor" id="line-200"></span></li></ul><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;highres&nbsp;-in&nbsp;whole_func&nbsp;-out&nbsp;whole_func2highres&nbsp;-omat&nbsp;whole_func2highres.mat</tt> <span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><ul><li>Now register highres to standard: <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span></li></ul><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;standard&nbsp;-in&nbsp;highres&nbsp;-out&nbsp;highres2standard&nbsp;-omat&nbsp;highres2standard.mat</tt> <span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><ul><li>Now combine the transforms: <span class="anchor" id="line-207"></span><span class="anchor" id="line-208"></span></li></ul><p class="line867"><tt class="backtick">convert_xfm&nbsp;-concat&nbsp;whole_func2highres.mat&nbsp;-omat&nbsp;example_func2highres.mat&nbsp;example_func2whole_func.mat</tt> <span class="anchor" id="line-209"></span><span class="anchor" id="line-210"></span><p class="line867"><tt class="backtick">convert_xfm&nbsp;-concat&nbsp;highres2standard.mat&nbsp;-omat&nbsp;example_func2standard.mat&nbsp;example_func2highres.mat</tt> <span class="anchor" id="line-211"></span><span class="anchor" id="line-212"></span><ul><li>Now you could use these to transform stats images (eg produced by FEAT) in the space of the original func data into standard space: <span class="anchor" id="line-213"></span><span class="anchor" id="line-214"></span></li></ul><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;standard&nbsp;-in&nbsp;thresh_zstat1&nbsp;-applyxfm&nbsp;-init&nbsp;example_func2standard.mat&nbsp;-out&nbsp;thresh_zstat12standard</tt> <span class="anchor" id="line-215"></span><span class="anchor" id="line-216"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-217"></span>
<h2 id="Using_with_FEAT">Using with FEAT</h2>
<span class="anchor" id="line-218"></span><p class="line862">If you want to put these transforms into a FEAT directory so that running group stats with FEAT will work well, then do the following (instead of using the simple default registration carried out by FEAT): Run a first level FEAT analysis without registration - this creates an output FEAT directory. Place in your FEAT directory appropriate images called <tt class="backtick">whole_func.hdr/.img</tt>, <tt class="backtick">highres.hdr/.img</tt> and <tt class="backtick">standard.hdr/.img</tt>. (<tt class="backtick">highres</tt> should probably have been brain-extracted already using BET, and standard should probably be <tt class="backtick">${FSLDIR}/data/standard/MNI152_T1_2mm_brain</tt>) Carry out the above <tt class="backtick">flirt</tt> and <tt class="backtick">convert_xfm</tt> commands exactly as written. This should leave you with correctly named transform files which FEAT will automatically use when carrying out group statistics. <span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-221"></span><a href="./CategoryFLIRT.html">CategoryFLIRT</a> <span class="anchor" id="line-222"></span><span class="anchor" id="bottom"></span></div>
</div>
<hr>
2017-04-20 13:28
</body>
</html>
